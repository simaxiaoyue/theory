# 事件委托

是什么？人为的利用冒泡实现的一种可以给动态元素注册事件的方式

有什么用？可以给动态生成的元素注册事件

怎么用？

原理：在已经存在的前代元素身上，先注册一个事件，一但后代元素触发了同类型的事件，判断一下，事件目标是否是满足条件的后代元素，如果满足，就执行某些代码

(这个可能比较难，尽量理解)

```js
// 在ul的身上注册事件，当事件处理程序被冒泡触发的时候，判断触发事件的事件目标是否满足条件
ul.onclick = function(e){
  // 如果满足条件，就执行代码
  if(e.target.nodeName === 'LI'){
    console.log('这是点击li触发的事件');
  }
}
```

# offset系列的属性

offsetParent

元素身上有一个offsetParent属性，这个属性是另一个元素

如果我的前代没有定位，我的offsetParent属性就是body或者是html

如果我的前代有定位，我的offsetParent就是一个离我最近的定位的前代元素

如果我自己做了固定定位，offsetParent就是null



存在两个属性

offsetLeft

得到我距离我的offsetParent的左边的距离

offsetTop

得到我距离我的offsetParent的顶部的距离





# 事件解绑

之前要让用户点击按钮有反应，我们称为事件注册，现在又希望点过一次之后，就不能再点了，其中一个较为推荐的解决方案 —— 事件解绑

让用户触发了事件之后，没反应了 —— 事件解绑 —— 是把事件处理程序和事件源的关联切断

注册事件有两个方式，解绑也对应的有两个

on的对应的方式

事件源.on事件类型 = null；

addEventListener对应的方式

事件源.removeEventListener(事件类型,函数名)

```jsx
let btn = document.querySelector('#btn');
btn.addEventListener('click',fn);
function fn(){
  btn.removeEventListener('click',fn)
  console.log(123);
}
```





# innerHTML和innerText的区别

innerHTML

​    是元素内部的html结构

在设置内容的时候，也是会覆盖原有的内容的，会把新内容里面的html解析的，会生成新的元素

  innerText

​    是元素内部的文本

​    在设置内容的时候，也是会覆盖原有的内容的，但是不会把新内容里面的html解析的，不会生成新的元素



# 定时器

一次性的定时

setTimeout(函数,延迟时间)

作用：延迟一段时间之后，把函数调用一次，时间是以毫秒为单位

返回值： 该定时器的id，该返回值会用于停止定时器的使用



永久性的定时器

setInterval(函数,延迟时间)  

作用： 每隔一段时间，执行函数一次

返回值： 该定时器的id，也是在我们想要停止的时候使用



如果要停止定时器，要使用对应的方式

setTimeout对应的是 clearTimeout(定时器id)

setInterval对应的是clearInterval(定时器id);



# 介绍一个简单的语法

箭头函数

箭头函数是es6里面推出的一个用于简写回调函数的语法

跟普通的函数有什么不同

语法格式不同，会更加简单

箭头函数里面的this，永远指向上一级作用域的this

注意：如果你在回调函数里面没有用到this，推荐使用箭头函数书写，但是如果用到了this，需要考虑，这个this到底是不是你想要的，如果是，才使用箭头函数

```js
（参数） => { 函数体 }
```

更简单的写法

如果函数只有一个参数，还可以简写成：参数 => {函数体}

```js
let fn = a => {
  console.log(a)
}
fn(10);
```

如果函数的函数体只有一句代码，也可以简写 ： () => 函数体

```js
let fn = (a,b) => console.log(a,b);
fn(10,20);
```



# localStorage

因为里面的数据是以键值对的方式存储的，我们在往里面存储数据的时候，也是要求以键值对的方式存储

在本地存储数据，需要使用对应的API

localStorage.setItem(key,value);

作用： 把键值对存储到本地数据

参数：

key : 根据这个键，要存储数据

value ： 要存储的数据

注意： 该方式只能存储字符串，如果你给的数据不是字符串，会自动转换为字符串再存储



在本地存储的数据里面，要获取出来

localStorage.getItem(key);

作用： 把存储在本地数据里面的东西获取出来

参数： key 当初以哪个键存进去，就以那个键取出来

返回值： 字符串 —— 永远是字符串或者是null

注意：如果没有这个键，就会返回null





# JSON

JSON是一种格式，存储数据的格式

格式的语法：

1.和js里面的对象几乎一样

2.所有的键都是要以双引号包起来的

3.数据类型只有两个：数字和字符串，字符串也是必须使用双引号包起来

4.其他就和js中差不多了

```js
js里面写对象
let obj = {
  name : '狗蛋'
  gender : true,
  age : 12
}
```

json里面表示数据

```json
{
  "name" : "狗蛋",
  "gender" : "男",
  "age" : 12
}
```

通常json格式会以字符串的形式存在。

我们开发中会经常的把对象转换为json格式，然后进行存储或者传输

js里面已经把转换的API封装好了，只需要学会怎么用

```js
// 把对象转换为json格式
JSON.stringify(对象)
// 作用 - 将对象转换为json格式的字符串
// 参数 ： 想要将什么转换为json格式字符串，就把什么放到参数里面
// 返回值： 就是json格式的字符串
```

还可以将字符串转换为对象

```js
JSON.parse(必须放一个满足json格式的字符串)
// 作用： 将json格式的字符串转换为对象
// 参数： json格式的字符串
// 返回值： 就是js里面的对象(也可能是数组)
```

# 键盘事件

keydown

在键盘按下的时候触发

keyup

在键盘的按键弹起的时候触发

如果要知道按下的按键是哪一个，从事件对象身上有一个属性 `keyCode` 得到一个每个按键对应的一个数字，一般就通过判断这个按下的keyCode查看到底是按下的是哪一个

如果想要判断是否同时按下了 ctrl 键，事件对象的一个属性 `ctrlKey`

这个属性返回的是布尔类型，如果是true代表同时按下了ctrl键

同理，研究shift和alt键



# 可视区域的大小

元素身上有一个属性，这个属性表示元素可视区域的大小，元素的可视区域大小就等于padding+content的大小

元素.clientWidth

元素.clientHeight

以上两个属性，就是用于获取可视区域的宽高



# 获取任意样式的当前值

window.getComputedStyle(element)

作用： 获取最终作用在该元素身上的所有的样式

参数： element 就是你要获取样式的元素

返回值： 是一个对象，对象里面有作用在该元素身上的所有的样式的集合

得到结果之后，想要什么属性的值，直接点出来，或者使用键的方式访问

但是注意： 从该对象身上得到所有的属性的值，都是字符串，当我们需要进行数值计算的时候，千万要记得转换为数字先





# 触摸事件

在移动端，是没有鼠标的，很多的鼠标的事件就用不了了，甚至在移动端，是不用鼠标事件的。移动端一般是触摸操作很多，一般在移动端使用的是触摸事件

触摸分为三个阶段

触摸开始 - touchstart - 会在手指触摸到屏幕的时候触发

触摸移动 - touchmove - 会在手指贴着屏幕并且发生移动的时候触发

触摸结束 - touchend - 会在手指离开屏幕的时候触发

注意点：

1.触摸事件必须在移动端才能触发

2.触摸事件推荐使用addEventListener的方式注册，因为很多移动端的事件都是基于h5和c3的



## 触摸事件里面的三个触摸点集合

在移动端的操作中，经常性要根据触摸的点，进行处理，需要在触摸事件里面使用事件的触摸点

在移动端里面，触摸事件有三个触摸点的集合

touches - 屏幕上面的触摸点

targetTouches - 元素上面的触摸点

changedTouches - 变化了的触摸点



注意点：

1.在单点操作的时候，触摸开始和触摸移动，三个触摸点集合是一样的

2.在触摸结束的时候，只能从 changedTouches这个集合中获取结束的位置



























